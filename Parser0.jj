PARSER_BEGIN(Parser)


/** ID lister. */
public class Parser {

  /** Main entry point. */
  public static void main(String args[]) {
    Parser parser = new Parser(System.in);
    ASTNode exp;

    while (true) {
      try {
        exp = parser.Start();
        System.out.println( exp.eval() );
      } catch (Exception e) {
        System.out.println ("Syntax Error!");
        parser.ReInit(System.in);
      }
    }
  }

}

PARSER_END(Parser)

SKIP :
{
  " "
| "\t"
| "\r"
}

TOKEN :
{
  < LESS: "<" >
  |
  < GREATER: ">" >
  |
  < LEQ: "<=" >
  |
  < GEQ: ">=" >
  |
  < AND: "&&" >
  |
  < OR: "||" >
  |
  < IF: "if" >
  |
  < THEN: "then" >
  |
  < ELSE: "else" >
  |
  < WHILE: "while" >
  |
  < DO: "do" >
  |
  < IN: "in" >
  |
  < END: "end" >
  |
  < BOOL: "true" | "false" >
  |
  < PRINT: "print" >
  |
  < ASSIGN : ":=" >
  |
  < EQCOMP : "==" >
  |
  < NEQCOMP : "!=" >
  |
  < NEW: "new" >
  |
  < SEQ: ";" >
  |
  < DEF: "def" >
  |
  //original para baixo
  < Id: ["a"-"z","A"-"Z"] ( ["a"-"z","A"-"Z","0"-"9"] )* >
  |
  < Num: (["0"-"9"]) + >
  |
  < PLUS : "+" >
  |
  < MINUS : "-">
  |
  < TIMES : "*">
  |
  < DIV : "/">
  |
  <NOT : "~"> 
  |
  < LPAR : "(" >
  |
  < RPAR : ")" >
  |
  < EL: "\n" >
  |
  < EQ: "=" >
}

ASTNode Start():
{ ASTNode t; }
{
   t = Exp() <EL>
   { return t; }
}

ASTNode Exp() :
{ Token op;
  ASTNode t1, t2; }
{
     t1=Term() ( ( op=<PLUS> | op=<MINUS> ) t2=Term() 
                 { if (op.kind == PLUS) 
                         t1 = new ASTPlus(t1,t2);
                   else  t1 = new ASTSub(t1,t2);
                 } 
               ) *
     { return t1; } 
}

ASTNode Term() :
{Token op;
  ASTNode t1, t2;}
{
     t1 = Fact() ( ( op=<TIMES> | op=<DIV> ) t2 = Term() 
 		 {  if(op.kind == TIMES)
              t1 = new ASTMul(t1,t2);
        else
              t1 = new ASTDiv(t1,t2);
      } 
		)?
     { return t1; } 
}

ASTNode Fact() :
{ Token n; 
  ASTNode t;}
{
   ( n=<Num> { t = new ASTNum(Integer.parseInt(n.image)); } 
    | 
    <LPAR> t=Exp() <RPAR>
    | 
    n = <NOT> 
    )
   { return t; }
}





















